const puppeteer = require("puppeteer");
const fs = require("fs").promises;
const path = require("path");
const config = require("../config");

class BrowserHelper {
    constructor() {
        this.browser = null;
        this.page = null;
        this.screenshotCounter = 0;
        this.testResults = [];
    }

    async init() {
        console.log("üöÄ Kh·ªüi t·∫°o browser...");
        try {
            this.browser = await puppeteer.launch({
                headless: true, // Ch·∫°y ·∫©n ƒë·ªÉ tr√°nh l·ªói GUI
                defaultViewport: { width: 1280, height: 720 },
                args: [
                    "--no-sandbox",
                    "--disable-setuid-sandbox",
                    "--disable-dev-shm-usage",
                    "--disable-accelerated-2d-canvas",
                    "--no-first-run",
                    "--no-zygote",
                    "--disable-gpu",
                    "--disable-web-security",
                    "--disable-features=VizDisplayCompositor",
                ],
                timeout: 30000,
                protocolTimeout: 60000,
            });
            this.page = await this.browser.newPage();
        } catch (error) {
            console.error("‚ùå L·ªói kh·ªüi t·∫°o browser:", error.message);
            throw error;
        }

        // Set timeouts
        this.page.setDefaultTimeout(config.timeouts.elementWait);
        this.page.setDefaultNavigationTimeout(config.timeouts.pageLoad);

        console.log("‚úÖ Browser ƒë√£ s·∫µn s√†ng");
    }

    async close() {
        if (this.browser) {
            await this.browser.close();
            console.log("üîí Browser ƒë√£ ƒë√≥ng");
        }
    }

    async navigate(url) {
        const fullUrl = url.startsWith("http")
            ? url
            : `${config.baseUrl}${url}`;
        console.log(`üìç ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn: ${fullUrl}`);

        try {
            // Ki·ªÉm tra xem page c√≥ c√≤n ho·∫°t ƒë·ªông kh√¥ng
            if (this.page.isClosed()) {
                throw new Error("Page ƒë√£ b·ªã ƒë√≥ng");
            }

            await this.page.goto(fullUrl, {
                waitUntil: "domcontentloaded",
                timeout: config.timeouts.pageLoad,
            });

            // ƒê·ª£i th√™m m·ªôt ch√∫t ƒë·ªÉ trang load ho√†n to√†n
            await this.sleep(2000);
            await this.waitForPageLoad();
            return true;
        } catch (error) {
            console.error(`‚ùå L·ªói ƒëi·ªÅu h∆∞·ªõng ƒë·∫øn ${fullUrl}:`, error.message);
            await this.captureScreenshot(`navigation_error_${Date.now()}`);
            throw error;
        }
    }

    async waitForPageLoad() {
        try {
            await this.page.waitForSelector("body", { timeout: 5000 });
            // ƒê·ª£i th√™m m·ªôt ch√∫t ƒë·ªÉ c√°c script load xong
            await this.page.waitForTimeout(1000);
        } catch (error) {
            console.warn("‚ö†Ô∏è Timeout ch·ªù page load, ti·∫øp t·ª•c...");
        }
    }

    async login(account) {
        console.log(`üîê ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n: ${account.email}`);

        try {
            await this.navigate(config.adminPanel);

            // ƒê·ª£i form login xu·∫•t hi·ªán v·ªõi timeout d√†i h∆°n
            await this.waitForElement('input[id="form.email"]', 15000);

            // ƒê·ª£i Livewire load ho√†n to√†n
            await this.sleep(2000);

            // Clear existing values and fill login form
            await this.page.click('input[id="form.email"]', { clickCount: 3 });
            await this.page.keyboard.press("Backspace");
            await this.page.type('input[id="form.email"]', account.email);

            await this.page.click('input[id="form.password"]', {
                clickCount: 3,
            });
            await this.page.keyboard.press("Backspace");
            await this.page.type('input[id="form.password"]', account.password);

            // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ form ƒë∆∞·ª£c ƒëi·ªÅn ƒë·∫ßy ƒë·ªß
            await this.sleep(2000);

            // Click n√∫t ƒëƒÉng nh·∫≠p
            await this.clickElement('button[type="submit"]');

            // ƒê·ª£i Livewire x·ª≠ l√Ω - ƒë·ª£i button kh√¥ng c√≤n loading
            try {
                await this.page.waitForFunction(
                    () => {
                        const button = document.querySelector(
                            'button[type="submit"]'
                        );
                        return (
                            button &&
                            !button.disabled &&
                            !button.classList.contains("fi-processing")
                        );
                    },
                    { timeout: 10000 }
                );
            } catch (e) {
                console.log("‚ö†Ô∏è Timeout ch·ªù Livewire, ti·∫øp t·ª•c...");
            }

            // ƒê·ª£i th√™m m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o
            await this.sleep(2000);

            // Ki·ªÉm tra xem c√≥ l·ªói ƒëƒÉng nh·∫≠p kh√¥ng
            const errorElements = await this.page.$$(
                ".fi-fo-field-error-message, .fi-notification-danger, .text-red-500, .fi-alert-danger"
            );
            if (errorElements.length > 0) {
                const errorText = await this.page.evaluate(() => {
                    const errors = document.querySelectorAll(
                        ".fi-fo-field-error-message, .fi-notification-danger, .text-red-500, .fi-alert-danger"
                    );
                    return Array.from(errors)
                        .map((el) => el.textContent)
                        .join(", ");
                });
                throw new Error(`ƒêƒÉng nh·∫≠p th·∫•t b·∫°i: ${errorText}`);
            }

            // Ki·ªÉm tra ƒëƒÉng nh·∫≠p th√†nh c√¥ng
            const currentUrl = this.page.url();
            if (
                currentUrl.includes("/admin") &&
                !currentUrl.includes("/login")
            ) {
                console.log("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng");
                await this.captureScreenshot(
                    `login_success_${account.email.split("@")[0]}`
                );
                return true;
            } else {
                // N·∫øu v·∫´n ·ªü trang login, c√≥ th·ªÉ c·∫ßn ƒë·ª£i th√™m
                await this.sleep(3000);
                const finalUrl = this.page.url();
                if (
                    finalUrl.includes("/admin") &&
                    !finalUrl.includes("/login")
                ) {
                    console.log("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng (sau delay)");
                    return true;
                }

                // N·∫øu v·∫´n th·∫•t b·∫°i, l·∫•y th√¥ng tin debug
                const pageContent = await this.page.content();
                const hasError =
                    pageContent.includes("error") ||
                    pageContent.includes("Error");
                throw new Error(
                    `ƒêƒÉng nh·∫≠p th·∫•t b·∫°i - URL: ${finalUrl}, Has Error: ${hasError}`
                );
            }
        } catch (error) {
            console.error(`‚ùå L·ªói ƒëƒÉng nh·∫≠p:`, error.message);
            await this.captureScreenshot(
                `login_error_${account.email.split("@")[0]}`
            );
            throw error;
        }
    }

    async logout() {
        console.log("üö™ ƒêƒÉng xu·∫•t...");

        try {
            // T√¨m v√† click n√∫t user menu
            const userMenuSelector =
                '[data-testid="user-menu"], .fi-topbar-user-menu, [aria-label*="user"], [aria-label*="account"]';
            await this.waitForElement(userMenuSelector, 5000);
            await this.clickElement(userMenuSelector);

            // T√¨m v√† click n√∫t logout
            const logoutSelector =
                'a[href*="logout"], button:contains("ƒêƒÉng xu·∫•t"), button:contains("Logout")';
            await this.waitForElement(logoutSelector, 3000);
            await this.clickElement(logoutSelector);

            // ƒê·ª£i redirect v·ªÅ trang login
            await this.page.waitForNavigation({ waitUntil: "networkidle2" });
            console.log("‚úÖ ƒêƒÉng xu·∫•t th√†nh c√¥ng");
        } catch (error) {
            console.warn("‚ö†Ô∏è Kh√¥ng th·ªÉ ƒëƒÉng xu·∫•t t·ª± ƒë·ªông, ti·∫øp t·ª•c...");
            // Th·ª≠ c√°ch kh√°c - clear session
            await this.page.evaluate(() => {
                localStorage.clear();
                sessionStorage.clear();
            });
        }
    }

    async waitForElement(selector, timeout = config.timeouts.elementWait) {
        try {
            await this.page.waitForSelector(selector, { timeout });
            return true;
        } catch (error) {
            console.error(`‚ùå Kh√¥ng t√¨m th·∫•y element: ${selector}`);
            await this.captureScreenshot(
                `missing_element_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async clickElement(selector, options = {}) {
        try {
            await this.waitForElement(selector);
            await this.page.click(selector, options);
            await this.page.waitForTimeout(config.timeouts.actionWait);
            console.log(`üñ±Ô∏è ƒê√£ click: ${selector}`);
            return true;
        } catch (error) {
            console.error(`‚ùå L·ªói click element: ${selector}`, error.message);
            await this.captureScreenshot(
                `click_error_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async typeText(selector, text) {
        try {
            await this.waitForElement(selector);
            await this.page.click(selector); // Focus v√†o input
            await this.page.keyboard.type(text);
            console.log(`‚å®Ô∏è ƒê√£ nh·∫≠p text: ${text} v√†o ${selector}`);
            return true;
        } catch (error) {
            console.error(`‚ùå L·ªói nh·∫≠p text: ${selector}`, error.message);
            await this.captureScreenshot(
                `type_error_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async selectOption(selector, value) {
        try {
            await this.waitForElement(selector);
            await this.page.select(selector, value);
            console.log(`üìã ƒê√£ ch·ªçn option: ${value} t·ª´ ${selector}`);
            return true;
        } catch (error) {
            console.error(`‚ùå L·ªói ch·ªçn option: ${selector}`, error.message);
            await this.captureScreenshot(
                `select_error_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async uploadFile(selector, filePath) {
        try {
            await this.waitForElement(selector);
            const input = await this.page.$(selector);
            await input.uploadFile(filePath);
            console.log(`üìÅ ƒê√£ upload file: ${filePath} v√†o ${selector}`);
            return true;
        } catch (error) {
            console.error(`‚ùå L·ªói upload file: ${selector}`, error.message);
            await this.captureScreenshot(
                `upload_error_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async getText(selector) {
        try {
            await this.waitForElement(selector);
            const text = await this.page.$eval(selector, (el) =>
                el.textContent.trim()
            );
            return text;
        } catch (error) {
            console.error(
                `‚ùå Kh√¥ng th·ªÉ l·∫•y text t·ª´: ${selector}`,
                error.message
            );
            return null;
        }
    }

    async getValue(selector) {
        try {
            await this.waitForElement(selector);
            const value = await this.page.$eval(selector, (el) => el.value);
            return value;
        } catch (error) {
            console.error(
                `‚ùå Kh√¥ng th·ªÉ l·∫•y value t·ª´: ${selector}`,
                error.message
            );
            return null;
        }
    }

    async isElementVisible(selector) {
        try {
            const element = await this.page.$(selector);
            if (!element) return false;

            const isVisible = await this.page.evaluate((el) => {
                const style = window.getComputedStyle(el);
                return (
                    style.display !== "none" &&
                    style.visibility !== "hidden" &&
                    style.opacity !== "0"
                );
            }, element);

            return isVisible;
        } catch (error) {
            return false;
        }
    }

    async waitForText(text, timeout = config.timeouts.elementWait) {
        try {
            await this.page.waitForFunction(
                (searchText) => document.body.textContent.includes(searchText),
                { timeout },
                text
            );
            console.log(`‚úÖ T√¨m th·∫•y text: ${text}`);
            return true;
        } catch (error) {
            console.error(`‚ùå Kh√¥ng t√¨m th·∫•y text: ${text}`);
            await this.captureScreenshot(
                `missing_text_${text.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw error;
        }
    }

    async captureScreenshot(name) {
        if (!config.screenshots.enabled) return;

        try {
            // T·∫°o th∆∞ m·ª•c screenshots n·∫øu ch∆∞a c√≥
            const screenshotDir = path.join(__dirname, "..", "screenshots");
            await fs.mkdir(screenshotDir, { recursive: true });

            // T·∫°o t√™n file v·ªõi timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
            const filename = `${timestamp}_${name}.${config.screenshots.format}`;
            const filepath = path.join(screenshotDir, filename);

            await this.page.screenshot({
                path: filepath,
                fullPage: true,
            });

            console.log(`üì∏ Screenshot saved: ${filename}`);
            return filepath;
        } catch (error) {
            console.error("‚ùå L·ªói ch·ª•p screenshot:", error.message);
        }
    }

    async assertElementExists(selector, message) {
        const exists = await this.isElementVisible(selector);
        if (!exists) {
            await this.captureScreenshot(
                `assert_failed_${selector.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw new Error(message || `Element kh√¥ng t·ªìn t·∫°i: ${selector}`);
        }
        console.log(`‚úÖ Assert passed: ${message || selector} t·ªìn t·∫°i`);
    }

    async assertTextContains(selector, expectedText, message) {
        const actualText = await this.getText(selector);
        if (!actualText || !actualText.includes(expectedText)) {
            await this.captureScreenshot(
                `assert_failed_text_${expectedText.replace(
                    /[^a-zA-Z0-9]/g,
                    "_"
                )}`
            );
            throw new Error(
                message ||
                    `Text kh√¥ng kh·ªõp. Expected: ${expectedText}, Actual: ${actualText}`
            );
        }
        console.log(`‚úÖ Assert passed: Text ch·ª©a "${expectedText}"`);
    }

    async assertUrlContains(expectedUrl, message) {
        const currentUrl = this.page.url();
        if (!currentUrl.includes(expectedUrl)) {
            await this.captureScreenshot(
                `assert_failed_url_${expectedUrl.replace(/[^a-zA-Z0-9]/g, "_")}`
            );
            throw new Error(
                message ||
                    `URL kh√¥ng kh·ªõp. Expected: ${expectedUrl}, Actual: ${currentUrl}`
            );
        }
        console.log(`‚úÖ Assert passed: URL ch·ª©a "${expectedUrl}"`);
    }

    // Helper ƒë·ªÉ t√¨m element v·ªõi nhi·ªÅu selector kh·∫£ nƒÉng
    async findElementBySelectors(selectors) {
        for (const selector of selectors) {
            try {
                await this.waitForElement(selector, 2000);
                return selector;
            } catch (error) {
                continue;
            }
        }
        throw new Error(
            `Kh√¥ng t√¨m th·∫•y element v·ªõi c√°c selector: ${selectors.join(", ")}`
        );
    }

    // Helper ƒë·ªÉ ƒë·ª£i v√† click element v·ªõi nhi·ªÅu selector kh·∫£ nƒÉng
    async clickBySelectors(selectors) {
        const selector = await this.findElementBySelectors(selectors);
        return await this.clickElement(selector);
    }

    // Helper ƒë·ªÉ ƒë·ª£i
    async sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}

module.exports = BrowserHelper;
